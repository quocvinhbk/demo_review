---

name: Deploy

on:
  workflow_dispatch:
  push:
    branches:
      - main

# Ref:
#   https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/control-the-concurrency-of-workflows-and-jobs
concurrency:
  group: deployment
  cancel-in-progress: false

env:
  BRANCH_NAME: ${{ github.ref_name }}
  WORKSPACE: /var/workspace
  CORE_DIRECTORY: demo_review
  CHROME_DRIVE_DIRECTORY: chromedriver_linux64
  ENVIRONMENT: production
  APP_ENV_FILENAME: .env
  PYENV_PYTHON_PATH: /root/.pyenv/shims/python
  VENV_PATH: venv/bin/activate
  BACKUP_OUTPUT_PATH: /var/backups

jobs:
  # build_env_file:
  #   runs-on: ubuntu-22.04
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v4
  #       with:
  #         ref: ${{ env.BRANCH_NAME }}

  #     - name: Config SSH
  #       uses: ./.github/actions/config_ssh
  #       with:
  #         HOST: ${{ secrets.PRODUCTION_HOST }}
  #         USERNAME: ${{ secrets.PRODUCTION_USERNAME }}
  #         PRIVATE_KEY: ${{ secrets.PRODUCTION_PRIVATE_KEY }}

  #     - name: Build ${{ env.APP_ENV_FILENAME }} file
  #       env:
  #         VARS: ${{ toJSON(vars) }}
  #       shell: bash
  #       run: |
  #         echo "$VARS" > vars.json
  #         deploy_scripts/json_to_env.py vars.json ${{ env.APP_ENV_FILENAME }} ${{ env.ENVIRONMENT }}

  #     - name: Copy ${{ env.APP_ENV_FILENAME }} file to ${{ env.ENVIRONMENT }}
  #       shell: bash
  #       run: |
  #         ssh ${{ secrets.PRODUCTION_HOST }} 'mkdir -p ${{ env.WORKSPACE }}/${{ env.CORE_DIRECTORY }}'
  #         scp ${{ env.APP_ENV_FILENAME }} ${{ secrets.PRODUCTION_HOST }}:${{ env.WORKSPACE }}/${{ env.CORE_DIRECTORY }}/

  deploy:
    # needs: build_env_file
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ env.BRANCH_NAME }}

      - name: Config SSH
        uses: ./.github/actions/config_ssh
        with:
          HOST: ${{ secrets.PRODUCTION_HOST }}
          USERNAME: ${{ secrets.PRODUCTION_USERNAME }}
          PRIVATE_KEY: ${{ secrets.PRODUCTION_PRIVATE_KEY }}

      - name: Fetch code
        shell: bash
        run: |
          ssh ${{ secrets.PRODUCTION_HOST }} 'cd ${{ env.WORKSPACE }}/${{ env.CORE_DIRECTORY }} && \
          git fetch --all --prune && \
          git checkout --force ${{ env.BRANCH_NAME }} || git checkout -b ${{ env.BRANCH_NAME }} origin/${{ env.BRANCH_NAME }} && \
          git reset --hard origin/${{ env.BRANCH_NAME }}'

      - name: Bundle install
        shell: bash
        run: |
          ssh ${{ secrets.PRODUCTION_HOST }} 'cd ${{ env.WORKSPACE }}/${{ env.CORE_DIRECTORY }} && \
          bash -lc "bundle install"
          '

      - name: Remove old chromedriver
        shell: bash
        run: |
          ssh ${{ secrets.PRODUCTION_HOST }} 'rm -f ${{ env.WORKSPACE }}/${{ env.CORE_DIRECTORY }}/chromedriver'

      - name: Add server chromedriver
        shell: bash
        run: |
          ssh ${{ secrets.PRODUCTION_HOST }} '\
          cp ${{ env.WORKSPACE }}/${{ env.CHROME_DRIVE_DIRECTORY }}/chromedriver ${{ env.WORKSPACE }}/${{ env.CORE_DIRECTORY }}/chromedriver && \
          chmod +x ${{ env.WORKSPACE }}/${{ env.CORE_DIRECTORY }}/chromedriver'

      - name: Remove old venv
        shell: bash
        run: |
          ssh ${{ secrets.PRODUCTION_HOST }} 'rm -rf ${{ env.WORKSPACE }}/${{ env.CORE_DIRECTORY }}/venv'

      - name: Add venv
        shell: bash
        run: |
          ssh ${{ secrets.PRODUCTION_HOST }} 'cd ${{ env.WORKSPACE }}/${{ env.CORE_DIRECTORY }} && \
          ${{ env.PYENV_PYTHON_PATH }} -m venv venv && \
          . ${{ env.VENV_PATH }} && pip install --upgrade pip && \
          . ${{ env.VENV_PATH }} && pip install -r requirements.txt && \
          . ${{ env.VENV_PATH }} && poetry lock --no-update && \
          . ${{ env.VENV_PATH }} && poetry install --no-root'

      - name: Create backup directory
        shell: bash
        run: |
          ssh ${{ secrets.PRODUCTION_HOST }} 'mkdir -p ${{ env.BACKUP_OUTPUT_PATH }}/${{ env.CORE_DIRECTORY }}'

      - name: Create output directory
        shell: bash
        run: |
          ssh ${{ secrets.PRODUCTION_HOST }} 'mkdir -p ${{ env.WORKSPACE }}/${{ env.CORE_DIRECTORY }}/output && \
          mkdir -p ${{ env.WORKSPACE }}/${{ env.CORE_DIRECTORY }}/input && \
          mkdir -p ${{ env.WORKSPACE }}/${{ env.CORE_DIRECTORY }}/log'

      - name: Update Cronjob
        shell: bash
        run: |
          ssh ${{ secrets.PRODUCTION_HOST }} 'cd ${{ env.WORKSPACE }}/${{ env.CORE_DIRECTORY }} && \
          bash -lc "whenever --update-crontab"'
